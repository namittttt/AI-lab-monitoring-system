import mongoose from 'mongoose';

const detectedObjectSchema = new mongoose.Schema({
  label: { type: String, required: true },  // e.g., 'person', 'laptop'
  count: { type: Number, required: true }
}, { _id: false });

const detectionEntrySchema = new mongoose.Schema({
  timestamp: { type: Date, default: Date.now },
  detectedObjects: { type: [detectedObjectSchema], default: [] },
  imagePath: { type: String, default: '' },
  // store session id explicitly for traceability
  sessionId: { type: mongoose.Schema.Types.ObjectId, ref: 'LabSession' }
}, { _id: false });

const detectionSchema = new mongoose.Schema({
  lab: { type: mongoose.Schema.Types.ObjectId, ref: 'Lab', required: true },
  labSession: { type: mongoose.Schema.Types.ObjectId, ref: 'LabSession', required: true },
  labName: { type: String, required: true },
  // array of detection entries (captures)
  detections: { type: [detectionEntrySchema], default: [] },
  // optionally keep a top-level summary count (redundant with LabSession but useful)
  detectionsCount: { type: Number, default: 0 },
  createdAt: { type: Date, default: Date.now }
});

const Detection = mongoose.model('Detection', detectionSchema);
export default Detection;// Backend/src/models/Lab.js
import mongoose from "mongoose";

const labSchema = new mongoose.Schema({
  name: { type: String, required: true },
  capacity: { type: Number, default: 10 },
  cameraStatus: { type: String, enum: ['online','offline','unknown'], default: 'unknown' },
  cameraIP: { type: String, required: true },
  ipRange: { type: String, default: '' },
  currentUtilization: { type: Number, default: 0 },
  createdAt: { type: Date, default: Date.now }
});

const Lab = mongoose.model('Lab',labSchema);
export default Lab ;
// module.exports = mongoose.model('Lab', labSchema);import mongoose from "mongoose";

const detectionConfigSchema = new mongoose.Schema({
  requiredCount: { type: Number, required: true }, // number of detections user wants
  startTime: { type: Date, required: true },
  endTime: { type: Date, required: true }
}, { _id: false });

const labSessionSchema = new mongoose.Schema({
  lab: { type: mongoose.Schema.Types.ObjectId, ref: 'Lab', required: true },
  labName: { type: String, required: true },

  startTime: { type: Date, required: true },
  endTime: { type: Date, required: true },

  numberOfDetections: { type: Number, required: true }, // user-specified
  detectionFrequency: { type: Number, default: 60 }, // seconds

  detectionConfig: detectionConfigSchema, // optional config

  // New fields to keep session-level summary
  lastDetectionAt: { type: Date },
  detectionsCount: { type: Number, default: 0 },

  createdAt: { type: Date, default: Date.now }
});

const LabSession = mongoose.model('LabSession', labSessionSchema);

export default LabSession;import { spawn } from 'child_process';
import path from 'path';
import fs from 'fs';
import Lab from '../models/Lab.model.js';
import LabSession from '../models/LabSession.model.js';
import Detection from '../models/detection.model.js';
import { getIo } from '../utils/socket.js'; // update path as per your project

const activeWorkers = new Map();

function safeJsonParse(s) {
  try { return JSON.parse(s); } catch { return null; }
}

function workerScriptPath() {
  const projectRoot = path.resolve(process.cwd(), '..');
  return path.resolve(projectRoot, 'yolovenv', 'detect_students.py');
}

export function sendCmd(state, obj, timeoutMs = 20000) {
  return new Promise((resolve, reject) => {
    if (!state || !state.child || state.child.killed) return reject(new Error('Worker not available'));
    const seq = ++state.seq;
    obj.seq = seq;
    const line = JSON.stringify(obj) + '\n';

    const timeout = setTimeout(() => {
      if (state.pending.has(seq)) {
        state.pending.delete(seq);
        reject(new Error('Worker response timeout'));
      }
    }, timeoutMs);

    state.pending.set(seq, { resolve, reject, timeout });
    try {
      state.child.stdin.write(line, 'utf8', (err) => {
        if (err) {
          clearTimeout(timeout);
          state.pending.delete(seq);
          return reject(err);
        }
      });
    } catch (e) {
      clearTimeout(timeout);
      state.pending.delete(seq);
      return reject(e);
    }
  });
}

function spawnWorker(lab, sessionId, saveDir) {
  const script = workerScriptPath();
  if (!fs.existsSync(script)) throw new Error(`Worker script not found at ${script}`);

  const args = [
    script,
    '--labId', lab._id.toString(),
    '--labName', lab.name,
    '--source', lab.cameraIP || '0',
    '--save-dir', saveDir || path.resolve(process.cwd(), 'screenshots', lab.name)
  ];

  const child = spawn('python', args, { cwd: process.cwd(), env: { ...process.env } });

  const state = {
    child,
    seq: 0,
    pending: new Map(),
    buf: '',
    isRunning: false
  };

  child.stdout.on('data', chunk => {
    state.buf += chunk.toString();
    let idx;
    while ((idx = state.buf.indexOf('\n')) >= 0) {
      const line = state.buf.slice(0, idx).trim();
      state.buf = state.buf.slice(idx + 1);
      if (!line) continue;
      const parsed = safeJsonParse(line);
      if (!parsed) {
        console.log(`[PY LOG][${sessionId}]`, line);
        continue;
      }
      const seq = parsed.seq;
      if (seq != null && state.pending.has(seq)) {
        const { resolve, timeout } = state.pending.get(seq);
        clearTimeout(timeout);
        state.pending.delete(seq);
        resolve(parsed);
      } else {
        console.log(`[PY MSG][${sessionId}]`, parsed);
      }
    }
  });

  child.stderr.on('data', d => console.error(`[PY ERR][${sessionId}]`, d.toString()));

  child.on('close', (code, sig) => {
    console.log(`Worker closed for ${sessionId} code=${code} sig=${sig}`);
    for (const [s, { reject, timeout }] of state.pending.entries()) {
      clearTimeout(timeout);
      reject(new Error('Worker exited'));
    }
    state.pending.clear();
    if (activeWorkers.has(sessionId)) {
      const ctrl = activeWorkers.get(sessionId);
      if (ctrl.intervalId) clearInterval(ctrl.intervalId);
      if (ctrl.startTimeoutId) clearTimeout(ctrl.startTimeoutId);
      activeWorkers.delete(sessionId);
    }
  });

  child.on('error', e => console.error('Worker spawn error', e));

  return state;
}

/**
 * Broadcast occupancy in real-time via Socket.IO
 */
async function broadcastOccupancy(lab, peopleCount) {
  const occupancyPercent = lab.capacity > 0
    ? Math.min(100, (peopleCount / lab.capacity) * 100)
    : 0;

   console.log(`[Occupancy] Lab: ${lab.name} | People: ${peopleCount} / Capacity: ${lab.capacity} | ${occupancyPercent.toFixed(2)}%`);
   
  getIo().emit('labOccupancyUpdate', {
    labId: lab._id,
    labName: lab.name,
    peopleCount,
    occupancyPercent: Number(occupancyPercent.toFixed(2))
  });

  // Also update current utilization in DB for dashboard reference
  await Lab.updateOne(
    { _id: lab._id },
    { $set: { currentUtilization: occupancyPercent } }
  );
}

// Save detection in DB + broadcast occupancy
async function persistDetection(lab, sessionId, json) {
  console.log(`[persistDetection] Called for sessionId=${sessionId}, lab=${lab.name}`);
  try {
    const activeSession = await LabSession.findById(sessionId);
    if (!activeSession) {
      console.warn(`Session ${sessionId} not found when saving detection`);
      return;
    }

    let doc = await Detection.findOne({
      lab: lab._id,
      labSession: activeSession._id
    });

    if (!doc) {
      doc = await Detection.create({
        lab: lab._id,
        labSession: activeSession._id,
        labName: lab.name,
        detections: [],
        detectionsCount: 0
      });
    }

    const detectedObjects = Array.isArray(json.detectedObjects) && json.detectedObjects.length
      ? json.detectedObjects.filter(o => typeof o.count === 'number')
      : (typeof json.count === 'number' ? [{ label: 'person', count: json.count }] : []);

    const peopleObj = detectedObjects.find(o => o.label.toLowerCase() === 'person');
    const peopleCount = peopleObj ? peopleObj.count : 0;

    const imagePath = json.screenshot
      ? path.join('screenshots', lab.name, path.basename(json.screenshot))
      : '';

    const entryTimestamp = json.timestamp ? new Date(json.timestamp) : new Date();

    await Detection.updateOne(
      { _id: doc._id },
      {
        $push: {
          detections: {
            timestamp: entryTimestamp,
            detectedObjects,
            imagePath,
            sessionId: activeSession._id
          }
        },
        $inc: { detectionsCount: 1 }
      }
    );

    await LabSession.updateOne(
      { _id: activeSession._id },
      {
        $set: {
          lastDetectionAt: entryTimestamp,
          sessionId: activeSession._id
        },
        $inc: { detectionsCount: 1 }
      }
    );

    // ✅ Broadcast occupancy in real-time
    await broadcastOccupancy(lab, peopleCount);

  } catch (err) {
    console.error('Error persisting detection:', err);
  }
}

export async function startSessionDetections(sessionId) {
  if (activeWorkers.has(sessionId)) {
    console.log(`Session ${sessionId} already running`);
    return;
  }

  const session = await LabSession.findById(sessionId);
  if (!session) {
    console.error(`Session ${sessionId} not found`);
    return;
  }

  const lab = await Lab.findById(session.lab);
  if (!lab) {
    console.error(`Lab for session ${sessionId} not found`);
    return;
  }

  const start = new Date(session.startTime);
  const end = new Date(session.endTime);
  const runs = session.numberOfDetections || 1;

  if (!(end > start)) {
    console.error('Invalid session times');
    return;
  }

  const totalSeconds = (end - start) / 1000;
  const intervalSeconds = totalSeconds / runs;

  console.log(`Starting session ${sessionId} (lab ${lab.name}) start=${start} end=${end} runs=${runs} every=${intervalSeconds}s`);

  const saveDir = path.resolve(process.cwd(), 'screenshots', lab.name);
  fs.mkdirSync(saveDir, { recursive: true });

  const state = spawnWorker(lab, sessionId, saveDir);

  const controller = {
    child: state.child,
    state,
    intervalId: null,
    startTimeoutId: null,
    runsDone: 0
  };

  activeWorkers.set(sessionId, controller);

  const doCapture = async () => {
    if (!activeWorkers.has(sessionId)) return;
    const now = new Date();
    if (now > end || controller.runsDone >= runs) {
      console.log(`Session ${sessionId} ended or runs completed`);
      await stopSessionDetections(sessionId);
      return;
    }
    if (state.isRunning) {
      console.log(`Previous capture still running for ${sessionId}, skipping`);
      return;
    }
    state.isRunning = true;
    try {
      const cmd = { cmd: 'capture', timestamp: new Date().toISOString() };
      const resp = await sendCmd(state, cmd, Math.max(15000, intervalSeconds * 1000));
      console.log(`[doCapture] Received response:`, resp);
      await persistDetection(lab, sessionId, resp);
      controller.runsDone += 1;
      console.log(`Session ${sessionId} capture ${controller.runsDone}/${runs} done`);
    } catch (err) {
      console.error(`Capture error for ${sessionId}:`, err.message || err);
    } finally {
      state.isRunning = false;
    }
  };

  const now = new Date();
  if (start > now) {
    const delay = start - now;
    controller.startTimeoutId = setTimeout(async () => {
      controller.startTimeoutId = null;
      await doCapture();
      controller.intervalId = setInterval(doCapture, Math.max(1000, intervalSeconds * 1000));
    }, delay);
    console.log(`Worker spawned. First capture scheduled in ${Math.round(delay / 1000)}s`);
  } else {
    console.log('Session start time is in the past or now. Starting capture immediately.');
    await doCapture();
    controller.intervalId = setInterval(doCapture, Math.max(1000, intervalSeconds * 1000));
  }
}

export async function stopSessionDetections(sessionId) {
  if (!activeWorkers.has(sessionId)) {
    console.log(`No active worker for ${sessionId}`);
    return;
  }
  const controller = activeWorkers.get(sessionId);
  if (controller.startTimeoutId) {
    clearTimeout(controller.startTimeoutId);
    controller.startTimeoutId = null;
  }
  if (controller.intervalId) {
    clearInterval(controller.intervalId);
    controller.intervalId = null;
  }

  const state = controller.state;
  try {
    if (state && state.child && !state.child.killed) {
      await sendCmd(state, { cmd: 'stop' }, 3000);
    }
  } catch {}

  setTimeout(() => {
    try {
      if (state && state.child && !state.child.killed) {
        state.child.kill('SIGTERM');
        console.log(`Force-killed worker for ${sessionId}`);
      }
    } catch (e) {
      console.error('Error force-killing worker:', e);
    }
  }, 2500);

  if (state && state.pending) {
    for (const [s, { reject, timeout }] of state.pending.entries()) {
      clearTimeout(timeout);
      reject(new Error('Session stopped'));
    }
    state.pending.clear();
  }

  activeWorkers.delete(sessionId);
  console.log(`Stopped detections for session ${sessionId}`);
}

export function stopAllDetections() {
  for (const id of Array.from(activeWorkers.keys())) {
    stopSessionDetections(id).catch(e => console.error(e));
  }
}

export function getWorkerStateBySessionId(sessionId) {
  const controller = activeWorkers.get(sessionId);
  return controller ? controller.state : null;
}

You already have Lab models in place, and your backend code starts running detection when a new LabSession is created for a specific lab.
Now, you want to introduce a Lab Timetable feature so that:
Each lab can have multiple sessions assigned to it in advance.
There can be many labs, and each lab’s timetable contains its specific sessions (start time, end time, and day).
The timetable should repeat automatically after a set interval (for demo purposes, every 2 days; later you can set it to 1 week or any other interval).
When the timetable repeats, the session date should update to the new period while keeping the same time slots.
Labs already exist (created via your existing labs route).
Sessions will be generated automatically from the timetable logic, so faculty can see them scheduled.

You need me to provide:
Model for LabTimetable (with repeating logic support).
Route to create/update timetables for labs.
Controller logic to save timetables and generate LabSessions for the upcoming period.
Cron/Server.js integration so that the timetable automatically generates sessions for the next cycle when the repeat date comes.